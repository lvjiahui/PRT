#version 430 core
#define SIZE 256

layout(local_size_x = SIZE) in;

uniform samplerCube environment;
layout (rgba32f, binding = 0) uniform image1D output_SH;

const float PI = 3.14159265359;
const float sampleDelta = 2*PI/SIZE;

shared vec4 phi_irradiance[SIZE][9];

//An Efficient Representation for Irradiance Environment Maps
float SH00(const vec3 d) {
  return 0.282095;
}

float SH1n1(const vec3 d) {
  return 0.488603 * d.y;
}

float SH10(const vec3 d) {
  return 0.488603 * d.z;
}

float SH1p1(const vec3 d) {
  return 0.488603 * d.x;
}

float SH2n2(const vec3 d) {
  return 1.092548 * d.x * d.y;
}

float SH2n1(const vec3 d) {
  return 1.092548 * d.y * d.z;
}

float SH20(const vec3 d) {
  return 0.315392 * (3.0 * d.z * d.z - 1);
}

float SH2p1(const vec3 d) {
  return 1.092548 * d.x * d.z;
}

float SH2p2(const vec3 d) {
  return 0.546274 * (d.x * d.x - d.y * d.y);
}

void main()
{
    uint xid = gl_GlobalInvocationID.x;
    for(int i = 0; i < 9; i++)
        phi_irradiance[xid][i] = vec4(0,0,0,1);

    float phi = sampleDelta * xid;
    float sin_phi = sin(phi);
    float cos_phi = cos(phi);

    for(float theta = 0.0; theta < PI; theta += sampleDelta){
        float sin_theta = sin(theta);
        float cos_theta = cos(theta);
        // spherical to cartesian
        vec3 sampleVec = vec3(sin_theta * cos_phi,  sin_theta * sin_phi, cos_theta);
        vec4 radiance = vec4(texture(environment, sampleVec.yzx).rgb, 1) * sin_theta; //convert from directX to openGL
        phi_irradiance[xid][0].rgb += radiance.rgb * SH00(sampleVec) ;
        phi_irradiance[xid][1].rgb += radiance.rgb * SH1n1(sampleVec);
        phi_irradiance[xid][2].rgb += radiance.rgb * SH10(sampleVec) ;
        phi_irradiance[xid][3].rgb += radiance.rgb * SH1p1(sampleVec);
        phi_irradiance[xid][4].rgb += radiance.rgb * SH2n2(sampleVec);
        phi_irradiance[xid][5].rgb += radiance.rgb * SH2n1(sampleVec);
        phi_irradiance[xid][6].rgb += radiance.rgb * SH20(sampleVec) ;
        phi_irradiance[xid][7].rgb += radiance.rgb * SH2p1(sampleVec);
        phi_irradiance[xid][8].rgb += radiance.rgb * SH2p2(sampleVec);

        // phi_irradiance[xid][0].a += radiance.a;
        // phi_irradiance[xid][1].a += radiance.a;
        // phi_irradiance[xid][2].a += radiance.a;
        // phi_irradiance[xid][3].a += radiance.a;
        // phi_irradiance[xid][4].a += radiance.a;
        // phi_irradiance[xid][5].a += radiance.a;
        // phi_irradiance[xid][6].a += radiance.a;
        // phi_irradiance[xid][7].a += radiance.a;
        // phi_irradiance[xid][8].a += radiance.a;
    }

    barrier();

    // reduce
    for (uint s = SIZE/2; s>0; s>>=1) {
        if (xid < s) {
            phi_irradiance[xid][0] += phi_irradiance[xid + s][0];
            phi_irradiance[xid][1] += phi_irradiance[xid + s][1];
            phi_irradiance[xid][2] += phi_irradiance[xid + s][2];
            phi_irradiance[xid][3] += phi_irradiance[xid + s][3];
            phi_irradiance[xid][4] += phi_irradiance[xid + s][4];
            phi_irradiance[xid][5] += phi_irradiance[xid + s][5];
            phi_irradiance[xid][6] += phi_irradiance[xid + s][6];
            phi_irradiance[xid][7] += phi_irradiance[xid + s][7];
            phi_irradiance[xid][8] += phi_irradiance[xid + s][8];
        }
        barrier();
    }

    // output
    if (xid == 0){
        for(int i = 0; i < 9; i++)
            imageStore(output_SH, i, phi_irradiance[0][i] * sampleDelta * sampleDelta);
    }

}
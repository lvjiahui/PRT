#version 430 core
#define SIZE 1 // TODO: That should be large, fix it!

#define THIRD_BAND

#ifdef THIRD_BAND
#define NUM_COEFF 9
#else
#define NUM_COEFF 4
#endif

layout(local_size_x = SIZE) in;
uniform samplerBuffer radiance;
uniform samplerBuffer transfer;
uniform usamplerBuffer range_ID;
uniform usampler3D probe_range;
vec3 surfel_SH[NUM_COEFF][SIZE];


const float PI = 3.14159265359;
const float c1 = 0.429043, c2 = 0.511664, c3 = 0.743125, c4 = 0.886227, c5 = 0.247708;
layout (rgba16f, binding = 0) restrict writeonly uniform image3D SH_Ar;
layout (rgba16f, binding = 1) restrict writeonly uniform image3D SH_Ag;
layout (rgba16f, binding = 2) restrict writeonly uniform image3D SH_Ab;
layout (rgba16f, binding = 3) restrict writeonly uniform image3D SH_Br;
layout (rgba16f, binding = 4) restrict writeonly uniform image3D SH_Bg;
layout (rgba16f, binding = 5) restrict writeonly uniform image3D SH_Bb;
layout (rgba16f, binding = 6) restrict writeonly uniform image3D SH_C;

void main()
{
    const int work_ID = int(gl_LocalInvocationID.x);
    for(int i = 0; i < NUM_COEFF; i++)
        surfel_SH[i][work_ID] = vec3(0);

    const ivec3 probe_id = ivec3(gl_WorkGroupID);
    ivec2 range = ivec2(texelFetch(probe_range, probe_id, 0).xy);
    const int workload = (range.y - range.x + SIZE-1) / SIZE;
    const int begin = range.x + workload * work_ID;

    for (int i = 0; i < workload; i++){
        if (begin + i < range.y){
            const int index = NUM_COEFF * (begin + i);
            const int ID = int(texelFetch(range_ID, begin + i).x);
            vec3 rad = texelFetch(radiance, ID).rgb;
            surfel_SH[0][work_ID] += texelFetch(transfer, index + 0).x * rad;
            surfel_SH[1][work_ID] += texelFetch(transfer, index + 1).x * rad;
            surfel_SH[2][work_ID] += texelFetch(transfer, index + 2).x * rad;
            surfel_SH[3][work_ID] += texelFetch(transfer, index + 3).x * rad;
#ifdef THIRD_BAND
            surfel_SH[4][work_ID] += texelFetch(transfer, index + 4).x * rad;
            surfel_SH[5][work_ID] += texelFetch(transfer, index + 5).x * rad;
            surfel_SH[6][work_ID] += texelFetch(transfer, index + 6).x * rad;
            surfel_SH[7][work_ID] += texelFetch(transfer, index + 7).x * rad;
            surfel_SH[8][work_ID] += texelFetch(transfer, index + 8).x * rad;
#endif
        }
    }

    barrier();

    // reduce
    for (uint s = SIZE/2; s>0; s>>=1) {
        if (work_ID < s) {
            surfel_SH[0][work_ID] += surfel_SH[0][work_ID + s];
            surfel_SH[1][work_ID] += surfel_SH[1][work_ID + s];
            surfel_SH[2][work_ID] += surfel_SH[2][work_ID + s];
            surfel_SH[3][work_ID] += surfel_SH[3][work_ID + s];
#ifdef THIRD_BAND
            surfel_SH[4][work_ID] += surfel_SH[4][work_ID + s];
            surfel_SH[5][work_ID] += surfel_SH[5][work_ID + s];
            surfel_SH[6][work_ID] += surfel_SH[6][work_ID + s];
            surfel_SH[7][work_ID] += surfel_SH[7][work_ID + s];
            surfel_SH[8][work_ID] += surfel_SH[8][work_ID + s];
#endif
        }
        barrier();
    }

    // output
    if (work_ID == 0){

        //windowing ?
        const vec3 L00 = surfel_SH[0][0].rgb;
        const vec3 L1n1= surfel_SH[1][0].rgb * 3.f/PI*sin(PI/3)    ;
        const vec3 L10 = surfel_SH[2][0].rgb * 3.f/PI*sin(PI/3)    ;
        const vec3 L1p1= surfel_SH[3][0].rgb * 3.f/PI*sin(PI/3)    ;
#ifdef THIRD_BAND
        const vec3 L2n2= surfel_SH[4][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2n1= surfel_SH[5][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L20 = surfel_SH[6][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2p1= surfel_SH[7][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2p2= surfel_SH[8][0].rgb * 3.f/2/PI*sin(2*PI/3);
#endif

        // Linear + constant polynomial terms : 2c2 (L11x + L1−1y + L10z) + c4L00 − c5L20
        const vec3 SH_Ax = 2*c2*L1p1;
        const vec3 SH_Ay = 2*c2*L1n1;
        const vec3 SH_Az = 2*c2*L10;
#ifdef THIRD_BAND
        const vec3 SH_Aw = c4*L00 - c5*L20;
#else
        const vec3 SH_Aw = c4*L00;
#endif
        imageStore(SH_Ar, probe_id, vec4(SH_Ax.r, SH_Ay.r, SH_Az.r, SH_Aw.r));
        imageStore(SH_Ag, probe_id, vec4(SH_Ax.g, SH_Ay.g, SH_Az.g, SH_Aw.g));
        imageStore(SH_Ab, probe_id, vec4(SH_Ax.b, SH_Ay.b, SH_Az.b, SH_Aw.b));
#ifdef THIRD_BAND
        // 4 of the quadratic polynomials : 2c1 (L2−2xy + L21xz + L2−1yz) +  c3L20z2
        const vec3 SH_Bxy = 2*c1*L2n2;
        const vec3 SH_Bxz = 2*c1*L2p1;
        const vec3 SH_Byz = 2*c1*L2n1;
        const vec3 SH_Bz2 = c3*L20;
        imageStore(SH_Br, probe_id, vec4(SH_Bxy.r, SH_Bxz.r, SH_Byz.r, SH_Bz2.r));
        imageStore(SH_Bg, probe_id, vec4(SH_Bxy.g, SH_Bxz.g, SH_Byz.g, SH_Bz2.g));
        imageStore(SH_Bb, probe_id, vec4(SH_Bxy.b, SH_Bxz.b, SH_Byz.b, SH_Bz2.b));
        // Final quadratic polynomial :  c1L22 (x2 - y2)
        imageStore(SH_C, probe_id, vec4(c1*L2p2, 1));
#endif
        
    }

    
}
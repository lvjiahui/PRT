#version 430 core
#define SIZE 64

#define THIRD_BAND

#ifdef THIRD_BAND
#define NUM_COEFF 9
#else
#define NUM_COEFF 4
#endif

layout(local_size_x = 1, local_size_y = SIZE) in;
uniform int probe_res;

uniform sampler2D WorldPos; //packed cubemap
uniform sampler2D Normal; //packed cubemap
uniform mat4 lightSpaceMatrix;

layout (rgba16f, binding = 0) restrict uniform image3D SH_Ar;
layout (rgba16f, binding = 1) restrict uniform image3D SH_Ag;
layout (rgba16f, binding = 2) restrict uniform image3D SH_Ab;
layout (rgba16f, binding = 3) restrict uniform image3D SH_Br;
layout (rgba16f, binding = 4) restrict uniform image3D SH_Bg;
layout (rgba16f, binding = 5) restrict uniform image3D SH_Bb;
layout (rgba16f, binding = 6) restrict uniform image3D SH_C;
shared vec4 tex_irradiance[NUM_COEFF][SIZE]; //TODO: performence sensitive to dimension

const float c1 = 0.429043, c2 = 0.511664, c3 = 0.743125, c4 = 0.886227, c5 = 0.247708;
float SH00(const vec3 d) {
  return 0.282095;
}

float SH1n1(const vec3 d) {
  return 0.488603 * d.y;
}

float SH10(const vec3 d) {
  return 0.488603 * d.z;
}

float SH1p1(const vec3 d) {
  return 0.488603 * d.x;
}

float SH2n2(const vec3 d) {
  return 1.092548 * d.x * d.y;
}

float SH2n1(const vec3 d) {
  return 1.092548 * d.y * d.z;
}

float SH20(const vec3 d) {
  return 0.315392 * (3.0 * d.z * d.z - 1);
}

float SH2p1(const vec3 d) {
  return 1.092548 * d.x * d.z;
}

float SH2p2(const vec3 d) {
  return 0.546274 * (d.x * d.x - d.y * d.y);
}

#include common/light.glsl
uniform CastLight light;
uniform PointLight ambient;
uniform ParalLight sky;

#include common/SH.glsl
uniform bool multi_bounce;
uniform float atten;

#include colored_wall.glsl
#include common/paral_shadow.glsl

float max3(vec3 v) {
  return max (max (v.x, v.y), v.z);
}

void main()
{
    const uint probe_xid = gl_WorkGroupID.x;
    const uint probe_yid = gl_WorkGroupID.y % probe_res;
    const uint probe_zid = gl_WorkGroupID.y / probe_res;
    const ivec3 probe_id = ivec3(probe_xid, probe_yid, probe_zid);
	  float ds = 2*scene_size / probe_res;
    const vec3 probe_pos = -scene_size + ds * (0.5 + vec3(probe_xid, probe_yid ,probe_zid));
    const uint tex_V = gl_LocalInvocationID.y;

    for(int i = 0; i < NUM_COEFF; i++)
        tex_irradiance[i][tex_V] = vec4(0,0,0,1);

    for (int face = 0; face < 6; face++){
        const ivec2 texStart = ivec2(SIZE * 6 * probe_xid + SIZE * face, gl_GlobalInvocationID.y);
        for(int tex_U = 0; tex_U < SIZE; tex_U++){
            const ivec2 texCoord = texStart + ivec2(tex_U, 0);
            vec3 texel_N = normalize(texelFetch(Normal, texCoord, 0).rgb);
            vec3 texel_pos = texelFetch(WorldPos, texCoord, 0).rgb;
            vec3 cubepos = texel_pos - probe_pos;
            cubepos = cubepos / max3(abs(cubepos));
            float fTmp = dot(cubepos, cubepos);
            float fWt = 1/(sqrt(fTmp)*fTmp); //solid angle
            const vec3 d = normalize(cubepos).zxy; // openGL to directX

            // relight
            vec3 rad = vec3(0,0,0);
            float shadow = ShadowCalculation(lightSpaceMatrix * vec4(texel_pos, 1.0), sky.direction, texel_N);
            rad += (1-shadow) * Eval_ParalLight(sky, texel_N);
            rad += Eval_CastLight(light, texel_pos, texel_N);
            rad += Eval_PointLight(ambient, texel_pos, texel_N);
            if(multi_bounce){
                rad += atten * SH_Irad(vec4(texel_N,1), texel_pos) / PI;
            }
            vec3 albedo = get_albedo(texel_pos);
            rad *= albedo;

            // project
            rad = fWt * rad;
            tex_irradiance[0][tex_V].rgb += rad * SH00(d) ;
            tex_irradiance[1][tex_V].rgb += rad * SH1n1(d);
            tex_irradiance[2][tex_V].rgb += rad * SH10(d) ;
            tex_irradiance[3][tex_V].rgb += rad * SH1p1(d);
#ifdef THIRD_BAND
            tex_irradiance[4][tex_V].rgb += rad * SH2n2(d);
            tex_irradiance[5][tex_V].rgb += rad * SH2n1(d);
            tex_irradiance[6][tex_V].rgb += rad * SH20(d) ;
            tex_irradiance[7][tex_V].rgb += rad * SH2p1(d);
            tex_irradiance[8][tex_V].rgb += rad * SH2p2(d);
#endif
        }
    }


    barrier();

    // reduce SIZE line
    for (uint s = SIZE/2; s>0; s>>=1) {
        if (tex_V < s) {
            tex_irradiance[0][tex_V] += tex_irradiance[0][tex_V + s];
            tex_irradiance[1][tex_V] += tex_irradiance[1][tex_V + s];
            tex_irradiance[2][tex_V] += tex_irradiance[2][tex_V + s];
            tex_irradiance[3][tex_V] += tex_irradiance[3][tex_V + s];
#ifdef THIRD_BAND
            tex_irradiance[4][tex_V] += tex_irradiance[4][tex_V + s];
            tex_irradiance[5][tex_V] += tex_irradiance[5][tex_V + s];
            tex_irradiance[6][tex_V] += tex_irradiance[6][tex_V + s];
            tex_irradiance[7][tex_V] += tex_irradiance[7][tex_V + s];
            tex_irradiance[8][tex_V] += tex_irradiance[8][tex_V + s];
#endif
        }
        barrier();
    }

    if (gl_LocalInvocationID.y < NUM_COEFF){
      tex_irradiance[gl_LocalInvocationID.y][0] *= (4.0 / SIZE / SIZE); //dudv
    }
    barrier();
    
    // output
    if (gl_LocalInvocationID.y == 0){
        // const uint probe_xid = gl_WorkGroupID.x;
        // const uint probe_yid = gl_WorkGroupID.y % probe_res;
        // const uint probe_zid = gl_WorkGroupID.y / probe_res;
        const ivec3 probe_id = ivec3(probe_xid, probe_yid, probe_zid);

        //windowing ?
        const vec3 L00 = tex_irradiance[0][0].rgb;
        const vec3 L1n1= tex_irradiance[1][0].rgb * 3.f/PI*sin(PI/3)    ;
        const vec3 L10 = tex_irradiance[2][0].rgb * 3.f/PI*sin(PI/3)    ;
        const vec3 L1p1= tex_irradiance[3][0].rgb * 3.f/PI*sin(PI/3)    ;
#ifdef THIRD_BAND
        const vec3 L2n2= tex_irradiance[4][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2n1= tex_irradiance[5][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L20 = tex_irradiance[6][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2p1= tex_irradiance[7][0].rgb * 3.f/2/PI*sin(2*PI/3);
        const vec3 L2p2= tex_irradiance[8][0].rgb * 3.f/2/PI*sin(2*PI/3);
#endif

        // Linear + constant polynomial terms : 2c2 (L11x + L1−1y + L10z) + c4L00 − c5L20
        const vec3 SH_Ax = 2*c2*L1p1;
        const vec3 SH_Ay = 2*c2*L1n1;
        const vec3 SH_Az = 2*c2*L10;
#ifdef THIRD_BAND
        const vec3 SH_Aw = c4*L00 - c5*L20;
#else
        const vec3 SH_Aw = c4*L00;
#endif
        imageStore(SH_Ar, probe_id, vec4(SH_Ax.r, SH_Ay.r, SH_Az.r, SH_Aw.r));
        imageStore(SH_Ag, probe_id, vec4(SH_Ax.g, SH_Ay.g, SH_Az.g, SH_Aw.g));
        imageStore(SH_Ab, probe_id, vec4(SH_Ax.b, SH_Ay.b, SH_Az.b, SH_Aw.b));
#ifdef THIRD_BAND
        // 4 of the quadratic polynomials : 2c1 (L2−2xy + L21xz + L2−1yz) +  c3L20z2
        const vec3 SH_Bxy = 2*c1*L2n2;
        const vec3 SH_Bxz = 2*c1*L2p1;
        const vec3 SH_Byz = 2*c1*L2n1;
        const vec3 SH_Bz2 = c3*L20;
        imageStore(SH_Br, probe_id, vec4(SH_Bxy.r, SH_Bxz.r, SH_Byz.r, SH_Bz2.r));
        imageStore(SH_Bg, probe_id, vec4(SH_Bxy.g, SH_Bxz.g, SH_Byz.g, SH_Bz2.g));
        imageStore(SH_Bb, probe_id, vec4(SH_Bxy.b, SH_Bxz.b, SH_Byz.b, SH_Bz2.b));
        // Final quadratic polynomial :  c1L22 (x2 - y2)
        imageStore(SH_C, probe_id, vec4(c1*L2p2, 1));
#endif
        
    }

    
}